/// I: DCC_Processing module
//    if (ProcessingON(confpath, time_step_one)) { // if DCC_Processing is SWITCH ON in the config.txt file
cout << "START of the DCC Processing module" << endl;
/*        if (P_type != "L") {
            special_face_design = DCC_Processing(special_faces_sequence, State_sVector, P_type);
        } else { // Vector of sfaces strips generated by RW
            for (int mu = 5; mu < 6; mu++) { //mu_f_max = 20
                mu_f = (double) mu;
                for (int sigm = 3; sigm < 4 ; sigm++) { //sigm_f_max = 0.7
                    sigm_f = (1.0 / (double) sigm) * 0.9;
                    special_face_design = DCC_Processing(special_faces_sequence, State_sVector, P_type, mu_f, sigm_f, RW_series_vector);
                } //  for (int sigm = 1; sigm < 10 ; sigm++)
            } // for (int mu = 2; mu < 3; mu++)
        }*/

special_face_design = DCC_Processing(special_faces_sequence, State_sVector, "R");

/// ===== Elapsing time Processing ================
//        if (ProcessingON(confpath, time_step_one)) {
unsigned int Processing_time = clock();
P_time = (double) Processing_time;
cout << "Processing time is equal to  " << P_time / pow(10.0, 6.0) << "  seconds" << endl;
cout << "-------------------------------------------------------" << endl;
//       } // end if(ProcessingON(confpath))

/// Cut special face sequence
double s_fraction = 0.1; // variable parameter
frac_sfaces_sequence.clear(); // part of sequence with certain fraction
for (unsigned int utr = 0; utr < special_faces_sequence.size()*s_fraction; ++utr) {
frac_sfaces_sequence.push_back(special_faces_sequence.at(utr));
}
cout << "frac_sfaces_sequence size:  " << frac_sfaces_sequence.size() << endl;

/// 0: DCC_Subcomplex module
//    if (SubcomplexON(confpath, time_step_one)) { // if DCC_Processing is SWITCH ON in the config.txt file
cout << "START of the DCC Subcomplex module" << endl;
unsigned int subcomplex_id_new = 0;
subcomplex new_Cut(subcomplex_id_new);
//       if (S_type == "P") { // subcomplex type  "plane cut"
new_Cut = subcomplex(subcomplex_id_new);

//  int D_initial_number = 1, nDsteps = 100;
//   for (int Dp_number = D_initial_number; Dp_number < nDsteps; ++ Dp_number) {
//       double Dp_value = (1.0/(double) nDsteps) * (double) Dp_number;
//       double a_p = 0.0, b_p = 0.0, c_p = 1.0, D_p = Dp_value;
//       DCC_Subcomplex(new_Cut, frac_sfaces_sequence, sub_sfaces_sequence, crack_faces_sequence, a_p, b_p, c_p, D_p);

double a_p = 0.0, b_p = 0.0, c_p = 1.0, D_p = 0.5; /// Must be the same as in the DCC_Subcomplex!!!
DCC_Subcomplex(new_Cut, frac_sfaces_sequence, sub_sfaces_sequence, crack_faces_sequence, a_p, b_p, c_p, D_p);
//            }
//    } // end of if (SubcomplexON(confpath, time_step_one))

cout << "plane_cut by DCC_Subcomplex was successfully created!" << endl;
/// ===== Elapsing time Subcomplex ================
unsigned int Subcomplex_time = clock();
double Sub_time = (double) Subcomplex_time - P_time;
cout << "Subcomplex time is equal to  " << Sub_time / pow(10.0, 6.0) << "  seconds" << endl;
cout << "-------------------------------------------------------" << endl;

///////////////// LOOP over crack steps /////////////////////
OutCrackEnergies_file.open(output_folder + "Crack_energies.txt"s, ios::trunc); // ofstream for crack energies
OutCrackEnergies_file << "(1) sfaces fraction" << "  " << "(2) Crack length ratio" << "  " << "(3) external vonMizes stress" << "  " << "(4) macro_crack.surface_energy" << "  " << "(5) macro_crack.bridging_energy" << "  " << "(6) multiple_cracking_energy" << "  " << "(7) crack_fraction" << endl;

int crack_id_new = 0;
int nsteps = 10;
int initial_step = 1;
for (int crack_length_number = initial_step; crack_length_number < nsteps; ++crack_length_number) {

/// Half-plane subcomplex
subcomplex half_plane_cut(new_Cut);
half_plane_cut.a_n = a_p; half_plane_cut.b_n = b_p; half_plane_cut.c_n = c_p; half_plane_cut.D_plane = D_p;
double length_ratio = (1.0/(double) nsteps) * (double) crack_length_number;
double crack_length = length_ratio; //* Lx_size; // Lx_size here Lx only now!!!
int half_subcomplex_id_new = 0;
// half_plane_cut

/// Half plane
half_plane_cut = new_Cut.Get_half_plane(new_Cut, crack_length, sub_sfaces_sequence); // half-plane method for a subcomplex

///News
cout << "half_plane_cut by Get_half_plane(plane_cut, crack_length) \"subcomplex\" class method was successfully created!" << endl;
unsigned int HalfPlane_time = clock();
double HP_time = (double) HalfPlane_time - Sub_time;
cout << "half plane cut takes time: " << HP_time/ pow(10.0, 6.0) << " s" << endl;

/// Multiphysics module : Macrocrack and the vector of macrocracks

/// number of "steps" in a crack growth path
++crack_id_new; // new crack id
// vector of macro-cracks as a PCC objects
large_cracks_vector.push_back(macrocrack(crack_id_new, half_plane_cut));
large_cracks_vector.at(crack_length_number-initial_step).Set_crack_plane(); // subcomplex based

///current crack
macrocrack large_crack = large_cracks_vector.at(crack_length_number-initial_step);

/// External stress value
double external_vonMizes_stress = 3.0 * pow(10.0, 8.0); // 300 MPa
face_elastic_energies.resize(CellNumbs.at(2), 0.0);

face_elastic_energies = DCC_Multiphysics(large_crack, external_vonMizes_stress);

///News
cout << "face_elastic_energies vector by DCC_Multiphysics module was successfully calculated!" << endl;
unsigned int MultiPhys = clock();
double MP_time = (double) MultiPhys - HP_time;
cout << "DCC_Multiphysics module takes time: " << MP_time / pow(10.0, 6.0) << " s" << endl;

/// III: DCC_Kinetic module
//if (KineticON(confpath, time_step_one)) { // if DCC_Kinetic is SWITCH ON in the config.txt file

cout << "START of the DCC Kinetic module" << endl;
kface_sequence = DCC_Kinetic(face_elastic_energies, frac_sfaces_sequence, large_crack, "F"s);

/// ===== Elapsing time Kinetic ================
unsigned int Kinetic_time = clock();
K_time = (double) Kinetic_time - MP_time;
cout << "Kinetic time is equal to  " << K_time / pow(10.0, 6.0) << "  seconds" << endl;
cout << "-------------------------------------------------------" << endl;
//}// end if(KineticON(confpath))

cout << "START of the DCC Writer module" << endl;
// DCC_Writer(special_faces_sequence, kface_sequence, State_sVector, mu_f, sigm_f, RW_series_vector, P_type);
//DCC_subcomplex_Writer(subcomplex_id_new, plane_cut, half_subcomplex_id_new, half_plane_cut, special_faces_sequence);
DCC_subcomplex_Writer(0, new_Cut, 1, half_plane_cut, frac_sfaces_sequence, kface_sequence, large_crack,
external_vonMizes_stress);

/// ===== Elapsing time Writer ================
unsigned int Writer_time = clock();
W_time = (double) Writer_time - K_time;
//    W_time = (double) Writer_time - K_time - MP_time - HP_time - Sub_time - P_time;
cout << "------" << endl;
cout << "Writer time is equal to  " << W_time / pow(10.0, 6.0) << "  seconds" << endl;

} // end of for loop over crack lengths
// } // end of for loop over the planes Dp
OutCrackEnergies_file.close();