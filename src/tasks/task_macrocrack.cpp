///=================================================================================================================================///
///================================ MACRO-CRACK SIMULATION TASK =============================================================///
///=================================================================================================================================///
#ifndef task_macrocrack_CPP
#define task_macrocrack_CPP
using namespace std;

/// I: DCC_Processing module
//    if (ProcessingON(confpath, time_step_one)) { // if DCC_Processing is SWITCH ON in the config.txt file
cout << "START of the DCC Processing module" << endl;
/*        if (P_type != "L") {
            special_face_design = DCC_Processing(special_faces_sequence, State_sVector, P_type);
        } else { // Vector of sfaces strips generated by RW
            for (int mu = 5; mu < 6; mu++) { //mu_f_max = 20
                mu_f = (double) mu;
                for (int sigm = 3; sigm < 4 ; sigm++) { //sigm_f_max = 0.7
                    sigm_f = (1.0 / (double) sigm) * 0.9;
                    special_face_design = DCC_Processing(special_faces_sequence, State_sVector, P_type, mu_f, sigm_f, RW_series_vector);
                } //  for (int sigm = 1; sigm < 10 ; sigm++)
            } // for (int mu = 2; mu < 3; mu++)
        }*/

special_face_design = DCC_Processing(special_faces_sequence, State_sVector, "R");

/// ===== Elapsing time Processing ================
//        if (ProcessingON(confpath, time_step_one)) {
unsigned int Processing_time = clock();
P_time = (double) Processing_time;
cout << "Processing time is equal to  " << P_time / pow(10.0, 6.0) << "  seconds" << endl;
cout << "-------------------------------------------------------" << endl;
//       } // end if(ProcessingON(confpath))

/// 0: DCC_Subcomplex module
//    if (SubcomplexON(confpath, time_step_one)) { // if DCC_Processing is SWITCH ON in the config.txt file
cout << "START of the DCC Subcomplex module" << endl;
unsigned int subcomplex_id_new = 0;
subcomplex new_Cut(subcomplex_id_new);
//       if (S_type == "P") { // subcomplex type  "plane cut"
/// specific parameters for a subcomplex PLANE CUT !!!
double a_p = 0.0, b_p = 0.0, c_p = 1.0, D_p = 0.9;
new_Cut = subcomplex(subcomplex_id_new);
DCC_Subcomplex(new_Cut, special_faces_sequence, crack_faces_sequence);
//            }
//    } // end of if (SubcomplexON(confpath, time_step_one))

cout << "plane_cut by DCC_Subcomplex was successfully created!" << endl;
/// ===== Elapsing time Subcomplex ================
unsigned int Subcomplex_time = clock();
double Sub_time = (double) Subcomplex_time - P_time;
cout << "Subcomplex time is equal to  " << Sub_time / pow(10.0, 6.0) << "  seconds" << endl;
cout << "-------------------------------------------------------" << endl;

/// Half-plane subcomplex
subcomplex half_plane_cut(new_Cut);
double length_ratio = 0.2;
double crack_length = length_ratio; //* Lx_size; // Lx_size here Lx only now!!!
int half_subcomplex_id_new = 0;
// half_plane_cut
half_plane_cut = new_Cut.Get_half_plane(new_Cut, crack_length); // half-plane method for a subcomplex

///News
cout << "half_plane_cut by Get_half_plane(plane_cut, crack_length) \"subcomplex\" class method was successfully created!" << endl;
unsigned int HalfPlane_time = clock();
double HP_time = (double) HalfPlane_time - Sub_time - P_time;
cout << "plane_cut takes time: " << HP_time/ pow(10.0, 6.0) << " s" << endl;

/// Multiphysics module : Macrocrack and the vector of macrocracks
int crack_id_new = 0;
// vector of macro-cracks as a PCC objects
large_cracks_vector.push_back(macrocrack(crack_id_new, half_plane_cut));
/*
    /// External stress value
    double external_vonMizes_stress = pow(10.0,8.0); // 100 MPa
    face_elastic_energies.resize(CellNumbs.at(2),0.0);
    face_elastic_energies = DCC_Multiphysics(large_cracks_vector, external_vonMizes_stress);

    ///News
    cout << "face_elastic_energies vector by DCC_Multiphysics module was successfully calculated!" << endl;
    unsigned int MultiPhys = clock();
    double MP_time = (double) MultiPhys - HP_time - Sub_time - P_time;
    cout << "DCC_Multiphysics module takes time: " << MP_time/ pow(10.0, 6.0) << " s" << endl;
*/
/*

/// III: DCC_Kinetic module
if (KineticON(confpath, time_step_one)) { // if DCC_Kinetic is SWITCH ON in the config.txt file

    cout << "START of the DCC Kinetic module" << endl;
    kface_sequence = DCC_Kinetic(face_elastic_energies, special_faces_sequence, K_type);

/// ===== Elapsing time Kinetic ================
    unsigned int Kinetic_time = clock();
    K_time = (double) Kinetic_time - MP_time - HP_time - Sub_time - P_time;
    cout << "Kinetic time is equal to  " << K_time / pow(10.0, 6.0) << "  seconds" << endl;
    cout << "-------------------------------------------------------" << endl;
}// end if(KineticON(confpath))
*/


cout << "START of the DCC Writer module" << endl;
// DCC_Writer(special_faces_sequence, kface_sequence, State_sVector, mu_f, sigm_f, RW_series_vector, P_type);
//DCC_subcomplex_Writer(subcomplex_id_new, plane_cut, half_subcomplex_id_new, half_plane_cut, special_faces_sequence);
DCC_subcomplex_Writer(0, new_Cut, 1, half_plane_cut, special_faces_sequence);

/// ===== Elapsing time Writer ================
unsigned int Writer_time = clock();
W_time = (double) Writer_time - K_time - HP_time - Sub_time - P_time;
//    W_time = (double) Writer_time - K_time - MP_time - HP_time - Sub_time - P_time;
cout << "------" << endl;
cout << "Writer time is equal to  " << W_time / pow(10.0, 6.0) << "  seconds" << endl;

#endif
